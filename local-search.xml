<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Resnet-SPPR（一）</title>
    <link href="/2025/09/22/Resnet-SPPR%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/09/22/Resnet-SPPR%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="resnet-sppr一数据处理">Resnet-SPPR（一）数据处理</h1><h2 id="数据集信息">数据集信息</h2><p>本节主要叙述在本项目的整个过程中的数据处理部分</p><p>一个好的数据集对于模型的准确度有着较大影响，本项目所选取的数据集来自deepsig公司推出的开源数据集RML2016.10a，该数据集的构建结合了GNURadio+python，进行了十一种调制模式（3种模拟调制+8种数字调制），详细见下表：</p><table><thead><tr><th style="text-align: left;">配置类型</th><th style="text-align: left;">配置信息</th></tr></thead><tbody><tr><td style="text-align: left;">数据源</td><tdstyle="text-align: left;">数字调制信号：莎士比亚的古腾堡作品；模拟调制信号：连续剧《SerialEpisode》</td></tr><tr><td style="text-align: left;">生成方式</td><td style="text-align: left;">Gnuradio + Python</td></tr><tr><td style="text-align: left;">数据格式</td><td style="text-align: left;">IQ（In-phase andQuadrature）数据格式：2×128</td></tr><tr><td style="text-align: left;">样本总量</td><td style="text-align: left;">220,000 (22 万)</td></tr><tr><td style="text-align: left;">采样率偏移标准偏差</td><td style="text-align: left;">0.01 Hz</td></tr><tr><td style="text-align: left;">最大采样率偏移</td><td style="text-align: left;">50 Hz</td></tr><tr><td style="text-align: left;">载波频率偏移标准差</td><td style="text-align: left;">0.01 Hz</td></tr><tr><td style="text-align: left;">最大载波频率偏移</td><td style="text-align: left;">500 Hz</td></tr><tr><td style="text-align: left;">频率选择性衰落正弦波数</td><td style="text-align: left;">8</td></tr><tr><td style="text-align: left;">调制方式</td><td style="text-align: left;"><strong>数字 (8 种)</strong>: 8PSK, BPSK,CPFSK, GFSK, PAM4, 16QAM, 64QAM, QPSK<br><strong>模拟 (3 种)</strong>:AM-DSB, AM-SSB, WBFM</td></tr><tr><td style="text-align: left;">信噪比 (SNR) 范围</td><td style="text-align: left;">-20 dB ~ 18 dB (间隔 2 dB)</td></tr><tr><td style="text-align: left;">采样率</td><td style="text-align: left;">200 kHz</td></tr><tr><td style="text-align: left;">延迟设置</td><td style="text-align: left;">[0.0, 0.9, 1.7]</td></tr><tr><td style="text-align: left;">每个延迟对应的幅度</td><td style="text-align: left;">[1, 0.8, 0.3]</td></tr><tr><td style="text-align: left;">噪声</td><td style="text-align: left;">加性高斯白噪声 (Additive White GaussianNoise, AWGN)</td></tr><tr><td style="text-align: left;">信道环境</td><td style="text-align: left;">加性高斯白噪声 (AWGN)、选择性衰落（莱斯(Rician) + 瑞利 (Rayleigh)）、中心频率偏移 (CFO)、采样率偏移 (SRO)</td></tr></tbody></table><h2 id="特征数据和标签数据处理">特征数据和标签数据处理</h2><p>该数据集储存三类信息，信号数据（features）、调制模式标签（labels）、信噪比（snr），本系统的构建思想是，以信噪比来进行大的模块的划分，信号数据作为训练数据，调制模式标签作为目标值来进行网络的训练。</p><p>在对数据集进行解压后，我将信号数据、调制模式、信噪比分别储存在特征数据、标签数据、信噪比标签三个列表内，在处理特征数据与标签数据时，因为本次采取的是残差神经网络，是将信号数据视作图片数据处理，所以对信号数据进行初始化（因为IQ数据振幅尺度较小），之后转为数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_data</span>(<span class="hljs-params">data, feature_range=(<span class="hljs-params"><span class="hljs-number">0</span>, <span class="hljs-number">1</span></span>)</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    准备特征数据和标签数据</span><br><span class="hljs-string"></span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    data: dict，输入数据字典，格式为 &#123;(modulation, snr): numpy_array&#125;</span><br><span class="hljs-string">    feature_range: tuple，归一化范围，默认为(0, 1)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    tuple: (features, labels, snr_labels) 三个numpy数组</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    features = []  <span class="hljs-comment"># 用于储存特征数据</span><br>    labels = []  <span class="hljs-comment"># 用于储存标签数据</span><br>    snr_labels = []  <span class="hljs-comment"># 用于存储信噪比标签</span><br><br>    <span class="hljs-comment"># 创建归一化器</span><br>    scaler = MinMaxScaler(feature_range=feature_range)<br><br>    <span class="hljs-keyword">for</span> (modulation, snr), value <span class="hljs-keyword">in</span> data.items():<br>        <span class="hljs-comment"># 原始数据</span><br>        original = value  <span class="hljs-comment"># 形状为 (6000, 2, 128)</span><br><br>        <span class="hljs-comment"># 对特征数据进行归一化</span><br>        <span class="hljs-comment"># 将数据形状调整为 (n_samples, 2*128) 以便应用归一化</span><br>        original_reshaped = original.reshape(original.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)<br>        normalized = scaler.fit_transform(original_reshaped)<br>        <span class="hljs-comment"># 将归一化后的数据恢复为原始形状 (n_samples, 2, 128)</span><br>        normalized = normalized.reshape(original.shape)<br><br>        features.append(normalized)<br>        <span class="hljs-comment"># 创建与特征数据对应的标签</span><br>        labels.append(np.full(value.shape[<span class="hljs-number">0</span>], modulation))<br>        <span class="hljs-comment"># 创建与特征数据对应的信噪比标签</span><br>        snr_labels.append(np.full(value.shape[<span class="hljs-number">0</span>], snr))<br><br>    <span class="hljs-comment"># 将所有特征数据堆叠成一个三维数组，形状为 (总样本数, 2, 128)</span><br>    features = np.vstack(features)<br><br>    <span class="hljs-comment"># 将所有标签数据堆叠成一个一维数组</span><br>    labels = np.hstack(labels)<br><br>    <span class="hljs-comment"># 将所有信噪比标签堆叠成一个一维数组</span><br>    snr_labels = np.hstack(snr_labels)<br><br>    <span class="hljs-comment"># 将列表转换为numpy数组并返回</span><br>    <span class="hljs-keyword">return</span> features,labels,snr_labels<br></code></pre></td></tr></table></figure><p>因为调制模式为字符串，所以我将调制模式映射为整数数组，没有采取独热编码形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_labels_to_indices</span>(<span class="hljs-params">labels</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    将字符串标签转换为整数索引</span><br><span class="hljs-string"></span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    labels: array-like，字符串标签数组</span><br><span class="hljs-string"></span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    tuple: (unique_labels, label_to_index, labels_int)</span><br><span class="hljs-string">           - 唯一标签数组</span><br><span class="hljs-string">           - 标签到索引的映射字典</span><br><span class="hljs-string">           - 转换后的整数标签数组</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 获取所有唯一的标签</span><br>    unique_labels = np.unique(labels)<br><br>    <span class="hljs-comment"># 创建标签到索引的映射</span><br>    label_to_index = &#123;label: idx <span class="hljs-keyword">for</span> idx, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(unique_labels)&#125;<br><br>    <span class="hljs-comment"># 将标签转换为整数索引</span><br>    labels_int = np.array([label_to_index[label] <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labels])<br><br>    <span class="hljs-keyword">return</span> unique_labels, label_to_index, labels_int<br></code></pre></td></tr></table></figure><p>在处理完特征数据、标签数据，完成标签整数化后，接下来将所有的列表转化为可以在GPU上进行训练的torch张量，调整特征数据形状以适应CNN输入，将形状从[batch_size, 2, 128] 调整为 [batch_size, 2, 1, 128]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_to_tensors</span>(<span class="hljs-params">features_np, labels_np, snr_labels_np</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    将NumPy数组转换为PyTorch张量</span><br><span class="hljs-string"></span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    features_np: numpy数组，特征数据，形状为 (样本数, 2, 128)</span><br><span class="hljs-string">    labels_np: numpy数组，标签数据，通常为整数</span><br><span class="hljs-string">    snr_labels_np: numpy数组，信噪比标签数据</span><br><span class="hljs-string"></span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    tuple: (features, labels, snr_labels) 三个PyTorch张量</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将特征数据转换为浮点型张量</span><br>    features = torch.tensor(features_np, dtype=torch.float32)<br><br>    <span class="hljs-comment"># 将标签数据转换为长整型张量</span><br>    labels = torch.tensor(labels_np, dtype=torch.long)<br><br>    <span class="hljs-comment"># 将信噪比标签转换为浮点型张量</span><br>    snr_labels = torch.tensor(snr_labels_np, dtype=torch.float32)<br><br>    <span class="hljs-keyword">return</span> features, labels, snr_labels<br></code></pre></td></tr></table></figure><h2 id="数据集制作">数据集制作</h2><p>在得到张量数据后，我根据[0.7, 0.05,0.25]的比例划分训练集、验证集和测试集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split_dataset</span>(<span class="hljs-params">features, labels, snr_labels, train_val_test_split</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    划分数据集为训练集、验证集和测试集</span><br><span class="hljs-string"></span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    features: 特征张量</span><br><span class="hljs-string">    labels: 标签张量</span><br><span class="hljs-string">    snr_labels: 信噪比标签张量</span><br><span class="hljs-string">    train_val_test_split: 包含三个比例值的列表 [训练集比例, 验证集比例, 测试集比例]</span><br><span class="hljs-string"></span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    划分后的九个数据集组件</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 计算各数据集大小</span><br>    train_size = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(features) * train_val_test_split[<span class="hljs-number">0</span>])<br>    val_size = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(features) * train_val_test_split[<span class="hljs-number">1</span>])<br>    test_size = <span class="hljs-built_in">len</span>(features) - train_size - val_size<br><br>    <span class="hljs-comment"># 随机打乱索引并重新排列数据</span><br>    indices = torch.randperm(<span class="hljs-built_in">len</span>(features))<br>    features = features[indices]<br>    labels = labels[indices]<br>    snr_labels = snr_labels[indices]<br><br>    <span class="hljs-comment"># 划分数据集</span><br>    train_X = features[:train_size]<br>    train_Y = labels[:train_size]<br>    train_snr_Y = snr_labels[:train_size]<br><br>    val_X = features[train_size: train_size + val_size]<br>    val_Y = labels[train_size: train_size + val_size]<br>    val_snr_Y = snr_labels[train_size: train_size + val_size]<br><br>    test_X = features[train_size + val_size:]<br>    test_Y = labels[train_size + val_size:]<br>    test_snr_Y = snr_labels[train_size + val_size:]<br><br>    <span class="hljs-comment"># 创建训练数据集</span><br>    train_dataset = TensorDataset(train_X, train_Y, train_snr_Y)<br><br>    <span class="hljs-comment"># 创建验证数据集</span><br>    val_dataset = TensorDataset(val_X, val_Y, val_snr_Y)<br><br>    <span class="hljs-comment"># 创建测试数据集</span><br>    test_dataset = TensorDataset(test_X, test_Y, test_snr_Y)<br><br>    <span class="hljs-keyword">return</span> train_dataset, val_dataset, test_dataset<br></code></pre></td></tr></table></figure><p>因为我是在笔记本上进行的模型训练，我的GPU显存只有8G，所以我在制作数据集加载器时尺寸较小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_data_loaders</span>(<span class="hljs-params">train_dataset, val_dataset, test_dataset, batch_size=<span class="hljs-number">256</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    创建训练、验证和测试数据加载器</span><br><span class="hljs-string"></span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    train_dataset: 训练数据集</span><br><span class="hljs-string">    val_dataset: 验证数据集</span><br><span class="hljs-string">    test_dataset: 测试数据集</span><br><span class="hljs-string">    batch_size: 批次大小，默认为256</span><br><span class="hljs-string"></span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    三个DataLoader对象: train_loader, val_loader, test_loader</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 创建训练数据加载器，随机打乱数据</span><br>    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># 创建验证数据加载器，不打乱数据</span><br>    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-comment"># 创建测试数据加载器，不打乱数据</span><br>    test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">return</span> train_loader, val_loader, test_loader<br></code></pre></td></tr></table></figure><p>至此，已经完成了数据集的制作与数据加载器的构建，下一节我将会搭建网络本体架构，以Resnet50为主体，结合多种注意力机制实现。</p>]]></content>
    
    
    <categories>
      
      <category>无线通信</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resnet-SPPR</title>
    <link href="/2025/09/22/Resnet-SPPR/"/>
    <url>/2025/09/22/Resnet-SPPR/</url>
    
    <content type="html"><![CDATA[<h1 id="resnet-sppr">Resnet-SPPR</h1><h2 id="总体概览">总体概览</h2><p>本系统采用由 deepsig 公司制作的数据集RML2016.10a[https://github.com/ianblenke/deepsig_dataset]</p><p>本系统可分辨的调制模式由以下十一种：8 个数字调制方式: 8PSK, BPSK,CPFSK, GFSK, PAM4, 16QAM, 64QAM, QPSK；3 个模拟调制方式：AM-DSB, AM-SSB,WBFM</p><p>信噪比范围为：-20dB~18dB,间隔 2dB</p><p>数据集主要配置见下表：</p><table><thead><tr><th style="text-align: left;">配置类型</th><th style="text-align: left;">配置信息</th></tr></thead><tbody><tr><td style="text-align: left;">数据源</td><tdstyle="text-align: left;">数字调制信号：莎士比亚的古腾堡作品；模拟调制信号：连续剧《SerialEpisode》</td></tr><tr><td style="text-align: left;">生成方式</td><td style="text-align: left;">Gnuradio + Python</td></tr><tr><td style="text-align: left;">数据格式</td><td style="text-align: left;">IQ（In-phase andQuadrature）数据格式：2×128</td></tr><tr><td style="text-align: left;">样本总量</td><td style="text-align: left;">220,000 (22 万)</td></tr><tr><td style="text-align: left;">采样率偏移标准偏差</td><td style="text-align: left;">0.01 Hz</td></tr><tr><td style="text-align: left;">最大采样率偏移</td><td style="text-align: left;">50 Hz</td></tr><tr><td style="text-align: left;">载波频率偏移标准差</td><td style="text-align: left;">0.01 Hz</td></tr><tr><td style="text-align: left;">最大载波频率偏移</td><td style="text-align: left;">500 Hz</td></tr><tr><td style="text-align: left;">频率选择性衰落正弦波数</td><td style="text-align: left;">8</td></tr><tr><td style="text-align: left;">调制方式</td><td style="text-align: left;"><strong>数字 (8 种)</strong>: 8PSK, BPSK,CPFSK, GFSK, PAM4, 16QAM, 64QAM, QPSK<br><strong>模拟 (3 种)</strong>:AM-DSB, AM-SSB, WBFM</td></tr><tr><td style="text-align: left;">信噪比 (SNR) 范围</td><td style="text-align: left;">-20 dB ~ 18 dB (间隔 2 dB)</td></tr><tr><td style="text-align: left;">采样率</td><td style="text-align: left;">200 kHz</td></tr><tr><td style="text-align: left;">延迟设置</td><td style="text-align: left;">[0.0, 0.9, 1.7]</td></tr><tr><td style="text-align: left;">每个延迟对应的幅度</td><td style="text-align: left;">[1, 0.8, 0.3]</td></tr><tr><td style="text-align: left;">噪声</td><td style="text-align: left;">加性高斯白噪声 (Additive White GaussianNoise, AWGN)</td></tr><tr><td style="text-align: left;">信道环境</td><td style="text-align: left;">加性高斯白噪声 (AWGN)、选择性衰落（莱斯(Rician) + 瑞利 (Rayleigh)）、中心频率偏移 (CFO)、采样率偏移 (SRO)</td></tr></tbody></table><p>本模型以 Resnet50 网络为基础，结合多种注意力机制，在进行 30轮训练的基础上，可实现对以上十一种调制模式的识别，整体准确率达91.29%，信噪比为 16.0dB 时，准确率可达 99.76%。</p><h2 id="结果可视化">结果可视化</h2><p><strong>整体准确率趋势图</strong></p><figure><img src="/img/Resnet-SPPR/1.png" alt="整体准确率趋势图" /><figcaption aria-hidden="true">整体准确率趋势图</figcaption></figure><p><strong>每个调制模式在不同信噪比下的准确性</strong></p><figure><img src="/img/Resnet-SPPR/2.png"alt="每个调制模式在不同信噪比下的准确性" /><figcaptionaria-hidden="true">每个调制模式在不同信噪比下的准确性</figcaption></figure><p><strong>模型损失曲线</strong></p><figure><img src="/img/Resnet-SPPR/3.png" alt="模型损失曲线" /><figcaption aria-hidden="true">模型损失曲线</figcaption></figure><p><strong>整体归一化混淆矩阵</strong></p><figure><img src="/img/Resnet-SPPR/4.png" alt="整体归一化混淆矩阵" /><figcaption aria-hidden="true">整体归一化混淆矩阵</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>无线通信</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号调制--AM调制</title>
    <link href="/2025/06/02/AM%E8%B0%83%E5%88%B6/"/>
    <url>/2025/06/02/AM%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="信号调制am-调制技术">信号调制–AM 调制技术</h1><h2 id="am-调制技术的产生与发展">AM 调制技术的产生与发展</h2><p>调幅（Amplitude Modulation, AM）技术诞生于 20 世纪初（1906 年Reginald Fessenden首次演示），是无线电通信的奠基性技术。其核心思想是通过基带信号（如语音）控制载波信号的振幅，实现信息传输。AM的优势在于：</p><ul><li><p>电路实现简单（二极管即可解调）</p></li><li><p>兼容性强（早期收音机核心方案）</p></li><li><p>带宽要求低（仅需基带信号 2 倍带宽）</p></li></ul><h2 id="am-调制的数学原理">AM 调制的数学原理</h2><h3 id="am-调制过程其数学过程如下">AM 调制过程其数学过程如下：</h3><p>设载波信号为：<br /><spanclass="math display"><em>c</em>(<em>t</em>) = <em>A</em><sub><em>c</em></sub>cos (2<em>π</em><em>f</em><sub><em>c</em></sub><em>t</em>)</span></p><p>基带信号为：<br /><spanclass="math display"><em>m</em>(<em>t</em>) = <em>A</em><sub><em>m</em></sub>cos (2<em>π</em><em>f</em><sub><em>m</em></sub><em>t</em>)</span></p><p>则 AM 调制信号可表示为：<br /><span class="math display">$$ s(t) = \underbrace{A*c}*{\text{载波振幅}}\left[1 + \underbrace{\mu}_{\text{调制指数}} \cdot m_n(t)\right]\cos(2\pi f_c t) $$</span></p><p>关键参数：</p><ul><li><p>调制指数：<span class="math inline">$\mu =\frac{A_m}{A_c}$</span> （需满足 <spanclass="math inline">0 ≤ <em>μ</em> ≤ 1</span> 避免过调制）</p></li><li><p>归一化基带信号：<span class="math inline">$m_n(t) =\frac{m(t)}{\max|m(t)|}$</span></p></li><li><p>频谱结构：载波分量 + 上下边带（带宽 <spanclass="math inline"> = 2<em>f</em><sub><em>m</em></sub></span>）</p></li></ul><h3 id="相干解调其数学过程如下">相干解调其数学过程如下：</h3><h4 id="接收信号与本地载波相乘">1. 接收信号与本地载波相乘</h4><p><spanclass="math display"><em>r</em>(<em>t</em>) = <em>s</em>(<em>t</em>) ⋅ cos (2<em>π</em><em>f</em><sub><em>c</em></sub><em>t</em>)</span><spanclass="math display"> = <em>A</em><sub><em>c</em></sub>[1 + <em>μ</em><em>m</em><sub><em>n</em></sub>(<em>t</em>)]cos<sup>2</sup>(2<em>π</em><em>f</em><sub><em>c</em></sub><em>t</em>)</span></p><h4 id="三角恒等式展开">2. 三角恒等式展开</h4><p><span class="math display">$$ \cos^2 \theta = \frac{1}{2} [1 +\cos(2\theta)] $$</span> <span class="math display">$$ \therefore r(t) =\frac{A_c}{2} [1 + \mu m_n(t)] \cdot [1 + \cos(4\pi f_c t)] $$</span><span class="math display">$$ = \frac{A_c}{2} [1 + \mu m_n(t)] +\frac{A_c}{2} [1 + \mu m_n(t)] \cos(4\pi f_c t) $$</span></p><p>第一项：<span class="math inline">$\frac{A_c}{2} [1 + \mum_n(t)]$</span> → 包含原始基带信息</p><p>第二项：<span class="math inline">$\frac{A_c}{2} [1 + \mu m_n(t)]\cos(4\pi f_c t)$</span> → 高频分量</p><h2 id="matlab-代码实现">matlab 代码实现</h2><p>本文基于 matlab 实现此调制方法，源代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-65ad56e5" role="button" aria-expanded="false" aria-controls="collapse-65ad56e5">        <div class="fold-arrow">▶</div>AM调制与解调matlab实现代码，点击展开即可阅览      </div>      <div class="fold-collapse collapse" id="collapse-65ad56e5">        <div class="fold-content">          <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clc; clear;<br><br><span class="hljs-comment">% AM调制与相干解调仿真</span><br>fs = <span class="hljs-number">10000</span>;             <span class="hljs-comment">% 采样率10kHz</span><br>t = <span class="hljs-number">0</span>:<span class="hljs-number">1</span>/fs:<span class="hljs-number">1</span>;           <span class="hljs-comment">% 1秒时间向量</span><br><br><span class="hljs-comment">% 生成基带信号（100Hz正弦波）</span><br>fm = <span class="hljs-number">100</span>;               <span class="hljs-comment">% 基带频率100Hz</span><br>Am = <span class="hljs-number">0.8</span>;               <span class="hljs-comment">% 基带振幅</span><br>m = Am*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);  <span class="hljs-comment">% 基带信号</span><br><br><span class="hljs-comment">% AM调制参数</span><br>fc = <span class="hljs-number">2000</span>;              <span class="hljs-comment">% 载波频率2kHz</span><br>Ac = <span class="hljs-number">1</span>;                 <span class="hljs-comment">% 载波振幅</span><br>mu = <span class="hljs-number">0.5</span>;               <span class="hljs-comment">% 调制指数</span><br><br><span class="hljs-comment">% 生成AM信号</span><br>carrier = Ac*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br>s_am = Ac*(<span class="hljs-number">1</span> + mu*m).*carrier;<br><br><span class="hljs-comment">% 本地载波（假设与发射端完全同步）</span><br>local_carrier = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br><br><span class="hljs-comment">% 接收信号与本地载波相乘</span><br>r = s_am .* local_carrier;<br><br><span class="hljs-comment">% 设计低通滤波器（截止频率设为基带频率的1.5倍）</span><br>f_cutoff = <span class="hljs-number">1.5</span>*fm;<br>normalized_cutoff = f_cutoff/(fs/<span class="hljs-number">2</span>);<br>[b, a] = butter(<span class="hljs-number">6</span>, normalized_cutoff, <span class="hljs-string">&#x27;low&#x27;</span>);<br><br><span class="hljs-comment">% 应用低通滤波</span><br>m_demod = filter(b, a, r);<br><br><span class="hljs-comment">% 去除直流偏移</span><br>m_demod = m_demod - <span class="hljs-built_in">mean</span>(m_demod);<br><br><span class="hljs-comment">% 幅度缩放（恢复原始信号幅度）</span><br>scale_factor = <span class="hljs-number">2</span>/(Ac*mu);<br>m_demod_scaled = m_demod * scale_factor;<br><br><span class="hljs-comment">% 创建3x2子图布局</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>]);<br><br><span class="hljs-comment">% 子图1: 原始信号时域图</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t, m, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br>title(<span class="hljs-string">&#x27;原始基带信号 (时域)&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>); ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>grid on;<br>xlim([<span class="hljs-number">0</span> <span class="hljs-number">0.05</span>]); <span class="hljs-comment">% 显示前50ms</span><br><br><span class="hljs-comment">% 子图2: 原始信号频谱图</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>f = <span class="hljs-built_in">linspace</span>(-fs/<span class="hljs-number">2</span>, fs/<span class="hljs-number">2</span>, <span class="hljs-built_in">length</span>(m));<br>M_fft = fftshift(fft(m));<br><span class="hljs-built_in">plot</span>(f, <span class="hljs-built_in">abs</span>(M_fft)/<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(M_fft)), <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br>title(<span class="hljs-string">&#x27;基带信号频谱&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;频率 (Hz)&#x27;</span>); ylabel(<span class="hljs-string">&#x27;归一化幅度&#x27;</span>);<br>grid on;<br>xlim([<span class="hljs-number">-500</span> <span class="hljs-number">500</span>]); <span class="hljs-comment">% 聚焦在基带频率附近</span><br><br><span class="hljs-comment">% 子图3: AM调制信号时域图</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t, s_am, <span class="hljs-string">&#x27;b&#x27;</span>, t, Ac*(<span class="hljs-number">1</span>+mu*m), <span class="hljs-string">&#x27;r--&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br>title(<span class="hljs-string">&#x27;AM调制信号 (时域)&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>); ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;调制信号&#x27;</span>,<span class="hljs-string">&#x27;包络&#x27;</span>, <span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;northeast&#x27;</span>);<br>grid on;<br>xlim([<span class="hljs-number">0</span> <span class="hljs-number">0.05</span>]); <span class="hljs-comment">% 显示前50ms</span><br><br><span class="hljs-comment">% 子图4: AM信号频谱图</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>f = <span class="hljs-built_in">linspace</span>(-fs/<span class="hljs-number">2</span>, fs/<span class="hljs-number">2</span>, <span class="hljs-built_in">length</span>(s_am));<br>S_am = fftshift(fft(s_am));<br><span class="hljs-built_in">plot</span>(f, <span class="hljs-built_in">abs</span>(S_am)/<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(S_am)), <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br>title(<span class="hljs-string">&#x27;AM调制信号频谱&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;频率 (Hz)&#x27;</span>); ylabel(<span class="hljs-string">&#x27;归一化幅度&#x27;</span>);<br>grid on;<br>xlim([<span class="hljs-number">-3000</span>, <span class="hljs-number">3000</span>]); <span class="hljs-comment">% 聚焦在载波频率附近</span><br><br><span class="hljs-comment">% 子图5: 解调后信号时域图</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(t, m, <span class="hljs-string">&#x27;b--&#x27;</span>, t, m_demod_scaled, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br>title(<span class="hljs-string">&#x27;解调后信号 (时域)&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>); ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;原始信号&#x27;</span>,<span class="hljs-string">&#x27;解调信号&#x27;</span>, <span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;northeast&#x27;</span>);<br>grid on;<br>xlim([<span class="hljs-number">0</span> <span class="hljs-number">0.05</span>]); <span class="hljs-comment">% 显示前50ms</span><br><br><span class="hljs-comment">% 子图6: 解调后信号频谱图</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);<br>f = <span class="hljs-built_in">linspace</span>(-fs/<span class="hljs-number">2</span>, fs/<span class="hljs-number">2</span>, <span class="hljs-built_in">length</span>(m_demod_scaled));<br>M_demod_fft = fftshift(fft(m_demod_scaled));<br><span class="hljs-built_in">plot</span>(f, <span class="hljs-built_in">abs</span>(M_demod_fft)/<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(M_demod_fft)), <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br>title(<span class="hljs-string">&#x27;解调信号频谱&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;频率 (Hz)&#x27;</span>); ylabel(<span class="hljs-string">&#x27;归一化幅度&#x27;</span>);<br>grid on;<br>xlim([<span class="hljs-number">-500</span> <span class="hljs-number">500</span>]); <span class="hljs-comment">% 聚焦在基带频率附近</span><br><br><span class="hljs-comment">% 添加整体标题</span><br>sgtitle(<span class="hljs-string">&#x27;AM调制与相干解调技术仿真分析 (fc=2000Hz, fm=100Hz, μ=0.5)&#x27;</span>, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">14</span>, <span class="hljs-string">&#x27;FontWeight&#x27;</span>, <span class="hljs-string">&#x27;bold&#x27;</span>);<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>运行结果如下： <img src="/img/信号调制/AM调制/2.png" /></p><h2 id="simulink-实现">Simulink 实现</h2><p>基于 Simulink 的 AM 调制建模如下： <imgsrc="/img/信号调制/AM调制/3.png" /></p><p>各部分的频谱如下：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/信号调制/AM调制/8.png" /></div><div class="group-image-wrap"><imgsrc="/img/信号调制/AM调制/9.png" /></div></div><div class="group-image-row"><div class="group-image-wrap"><imgsrc="/img/信号调制/AM调制/10.png" /></div><div class="group-image-wrap"><imgsrc="/img/信号调制/AM调制/11.png" /></div></div></div><p>整体波形图如下： <img src="/img/信号调制/AM调制/12.png" /></p><h2 id="gnuradio-实现">GNURadio 实现</h2><p>基带信号的波形与频谱图 <img src="/img/信号调制/AM调制/4.png" /></p><p>已调信号的波形和频谱图 <img src="/img/信号调制/AM调制/5.png" /></p><p>解调信号的波形和频谱图 <img src="/img/信号调制/AM调制/6.png" /></p><p>基于 GNURadio 搭建的流图如下： <imgsrc="/img/信号调制/AM调制/7.png" /></p>]]></content>
    
    
    <categories>
      
      <category>信号调制</category>
      
      <category>通信技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>GNURadio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档撰写教学</title>
    <link href="/2025/06/01/%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2/"/>
    <url>/2025/06/01/%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="博客文档撰写教学">博客文档撰写教学</h1><p>正文的一部分作为摘要，这一部分是摘要</p><span id="more"></span><h2 id="插入图片测试">插入图片测试</h2><p>这里会插入一张测试图片，用以测试图片是否正常上传 <imgsrc="/img/文档撰写教学/2.png" /></p><h2 id="文字输入测试">文字输入测试</h2><p>小写字母</p><p>qwertyuiopasdfghjklzxcvbnm</p><p>大写字母</p><p>QWERTYUIOPASDFGHJKLZXCVBNM</p><p>数字</p><p>0123456789</p><p>符号</p><p>/<em>-+.！@#￥%……&amp;</em>（）——+-={}|【】、：“《》？<span></span>|:“&lt;&gt;?</p><h2 id="代码输入测试">代码输入测试</h2><p>这里测试代码块，一段简单的代码</p><p>C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello world\n&quot;</span>&lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="tag-标签测试">Tag 标签测试</h2><div class="note note-primary">            <p>primary 标签</p>          </div><div class="note note-secondary">            <p>secondary 标签</p>          </div><div class="note note-success">            <p>success 标签</p>          </div><div class="note note-danger">            <p>danger 标签</p>          </div><div class="note note-waring">            <p>waring 标签</p>          </div><div class="note note-info">            <p>info 标签</p>          </div><div class="note note-light">            <p>light 标签</p>          </div><span class="label label-primary">这是一段行内注释</span>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-b5714680" role="button" aria-expanded="false" aria-controls="collapse-b5714680">        <div class="fold-arrow">▶</div>这里是一段折叠代码，里面支持md格式      </div>      <div class="fold-collapse collapse" id="collapse-b5714680">        <div class="fold-content">          <p>需要折叠的一段内容，支持 markdown</p>        </div>      </div>    </div>            <input type="checkbox"  checked="checked">选择框是否选中          <h1 id="pandoc-数学公式示例">Pandoc 数学公式示例</h1><p>这里是一段公式编辑</p><p>行内公式：<spanclass="math inline"><em>a</em><sup>2</sup> + <em>b</em><sup>2</sup> = <em>c</em><sup>2</sup></span></p><p>块级公式：</p><p><span class="math display">$$\oint_C \vec{E} \cdot d\vec{l} = -\frac{d\Phi_B}{dt}$$</span></p><p>矩阵运算：</p><p><span class="math display">$$A = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix}, \quad \det(A)= 1 \times 4 - 2 \times 3 = -2$$</span></p><p>分段函数：</p><p><span class="math display">$$P(X=k) = \begin{cases}p^k (1-p)^{1-k}, &amp; \text{if } k \in \{0,1\} \\0, &amp; \text{otherwise}\end{cases}$$</span></p><h2 id="流程图测试">流程图测试</h2><pre><code class="mermaid" >ganttdateFormat YYYY-MM-DDtitle Adding GANTT diagram to mermaidsection A sectionCompleted task :done, des1, 2014-01-06,2014-01-08Active task :active, des2, 2014-01-09, 3dFuture task : des3, after des2, 5dFuture task2 : des4, after des3, 5d</code></pre>]]></content>
    
    
    <categories>
      
      <category>博客撰写</category>
      
      <category>基础文件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>文档撰写教学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
